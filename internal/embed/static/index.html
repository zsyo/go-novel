<!DOCTYPE html>
<html lang="zh">
<head>
  <meta charset="UTF-8">
  <!-- 移动端视口设置 -->
  <meta content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1" name="viewport">
  <!-- 安卓/Chrome Web App 全屏显示 -->
  <meta content="yes" name="mobile-web-app-capable">
  <!-- iOS Safari 全屏显示（保留兼容） -->
  <meta content="yes" name="apple-mobile-web-app-capable">
  <!-- 禁止 iOS 自动识别电话号码 -->
  <meta content="telephone=no" name="format-detection">
  <title>Go Novel</title>
  <link href="/favicon.ico" rel="icon" type="image/x-icon">
  <link rel="stylesheet" href="/css/index.css">
</head>
<body>
<div class="wrap-container">
  <header class="header">
    <div class="header-content">
      <h1 class="app-title">Go Novel</h1>
    </div>
  </header>
  <main class="main-content">
    <section class="container download-container card" id="downloadContainer">
      <h2 class="section-title">搜索书籍</h2>
      <div class="search-container">
        <input id="downloadSearchName" placeholder="请输入书名或作者，尽量输完整" aria-label="搜索书名或作者">
        <button class="btn btn-primary btn-search" id="searchButton">搜索</button>
      </div>
      <div class="body-container">
        <div class="table-responsive">
          <table class="data-table">
            <thead>
            <tr>
              <th scope="col">序号</th>
              <th scope="col">书名</th>
              <th scope="col">作者</th>
              <th scope="col">最新章节</th>
              <th scope="col">最后更新时间</th>
              <th scope="col">书源</th>
              <th scope="col">操作</th>
            </tr>
            </thead>
            <tbody id="downloadTableBody">
            </tbody>
          </table>
        </div>
      </div>
    </section>
    <section class="container result-container card">
      <h2 class="section-title">已下书籍</h2>
      <div class="search-container">
        <button id="refreshList" class="btn btn-primary">刷新列表</button>
      </div>
      <div class="body-container">
        <div class="table-responsive">
          <table class="data-table">
            <thead>
            <tr>
              <th scope="col">文件名</th>
              <th scope="col">文件大小</th>
              <th scope="col">下载时间</th>
              <th scope="col">操作</th>
            </tr>
            </thead>
            <tbody id="tableBody">
            </tbody>
          </table>
        </div>
      </div>
    </section>
  </main>
</div>
<div class="loading-container" id="tipEle">
  <div class="content">
    <svg class="loading-icon" viewBox="0 0 100 100">
      <circle cx="50" cy="50" r="45" fill="none" stroke="#fff" stroke-width="8" stroke-dasharray="141.37 87.96"
              stroke-linecap="round"></circle>
    </svg>
    <span class="text" id="tipText">正在下载</span>
    <div class="progress-container" id="progressContainer" style="display: none;">
      <div class="progress-bar" id="progressBar"></div>
      <div class="progress-text" id="progressText">0%</div>
    </div>
    <!-- 添加停止下载按钮 -->
    <button class="btn btn-danger stop-download-btn" id="stopDownloadBtn" style="display: none; margin-top: 10px;">停止下载</button>
  </div>
</div>
<script>
  document.addEventListener('DOMContentLoaded', () => {
    // DOM 元素引用
    const downloadContainer = document.getElementById('downloadContainer')
    const downloadSearchName = document.getElementById('downloadSearchName')
    const searchButton = document.getElementById('searchButton')
    const refreshListButton = document.getElementById('refreshList')
    const downloadTableBody = document.getElementById('downloadTableBody')
    const tableBody = document.getElementById('tableBody')
    const tipEle = document.getElementById('tipEle')
    const tipText = document.getElementById('tipText')
    const progressContainer = document.getElementById('progressContainer')
    const progressBar = document.getElementById('progressBar')
    const progressText = document.getElementById('progressText')
    const stopDownloadBtn = document.getElementById('stopDownloadBtn') // 添加停止下载按钮引用

    let bookCache = []
    // 最新下载的书的文件名
    let latestFileName = ''
    // 下载状态
    let isDownloading = false
    // 全局SSE连接状态
    let globalSseConnected = false
    // 当前下载的书籍ID（用于停止下载）
    let currentDownloadId = null
    // 客户端ID，用于SSE连接标识
    let clientId = null

    // 工具函数
    // 生成UUID函数
    const generateUUID = () => {
      // 优先使用Crypto API生成UUID
      if (typeof crypto !== 'undefined' && crypto.randomUUID) {
        // 使用现代浏览器提供的Crypto API生成UUID
        return crypto.randomUUID();
      } else {
        // 降级方案：使用Math.random生成UUID格式的字符串
        return 'xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx'.replace(/[xy]/g, function(c) {
          var r = Math.random() * 16 | 0,
              v = c == 'x' ? r : (r & 0x3 | 0x8);
          return v.toString(16);
        });
      }
    }
    
    // 页面加载时生成客户端ID
    clientId = generateUUID();
    console.log('[页面]生成客户端ID:', clientId);

    const showTip = (text = '正在加载...', showProgress = false) => {
      tipText.innerHTML = text
      tipEle.style.display = 'flex'
      
      // 显示或隐藏进度条
      progressContainer.style.display = showProgress ? 'block' : 'none'
      // 显示或隐藏停止下载按钮（仅在显示进度时显示）
      stopDownloadBtn.style.display = showProgress ? 'block' : 'none'
      if (showProgress) {
        // 重置进度条
        updateProgress(0, 100)
      }
    }

    const updateTip = (text) => {
      tipText.innerHTML = text
    }

    const hideTip = () => {
      tipEle.style.display = 'none'
      // 注意：不在这里重置isDownloading状态，因为有时候我们需要手动控制这个状态
      // isDownloading = false 已移至其它地方显式设置
    }
    
    // 更新进度条
    const updateProgress = (current, total) => {
      if (total <= 0) return
      
      const percent = Math.floor((current / total) * 100)
      progressBar.style.width = `${percent}%`
      progressText.textContent = `${percent}%(${current}/${total})`
    }

    const formatSize = (bytes) => {
      if (bytes === 0) return '0.00 B'
      const k = 1024
      const sizes = ['B', 'KB', 'MB', 'GB']
      const i = Math.floor(Math.log(bytes) / Math.log(k))
      const sizeValue = (bytes / Math.pow(k, i)).toFixed(2)
      return `${sizeValue} ${sizes[i]}`
    }

    const formatDate = (timestamp) => {
      const date = new Date(timestamp)
      return date.toLocaleString('zh-CN', {
        year: 'numeric',
        month: '2-digit',
        day: '2-digit',
        hour: '2-digit',
        minute: '2-digit',
        second: '2-digit'
      })
    }

    // 事件处理函数
    const handleDownloadFileToLocal = (name) => {
      console.log('download to local', `《${name}》`)
      window.open(`/api/book/download?filename=${encodeURIComponent(name)}`, '_blank')
    }

    // 停止下载函数
    const handleStopDownload = async () => {
      if (!isDownloading) {
        return;
      }
      
      if (!currentDownloadId) {
        alert('无法停止下载，没有正在进行的下载任务');
        return;
      }
      
      if (!confirm('确定要停止当前下载吗？')) {
        return;
      }
      
      try {
        updateTip('正在停止下载...');
        
        // 发送停止下载请求到后端
        const response = await fetch(`/api/book/stop-download?downloadId=${encodeURIComponent(currentDownloadId)}`, {
          method: 'POST'
        });
        
        const result = await response.json();
        
        if (response.ok && result.message) {
          updateTip('下载已停止');
          isDownloading = false;
          currentDownloadId = null;
          
          // 2秒后隐藏提示
          setTimeout(() => {
            hideTip();
          }, 2000);
        } else {
          updateTip(`停止下载失败: ${result.error || '未知错误'}`);
          setTimeout(() => {
            hideTip();
          }, 2000);
        }
      } catch (error) {
        console.error('停止下载失败:', error);
        updateTip('停止下载失败');
        setTimeout(() => {
          hideTip();
        }, 2000);
      }
    }

    const handleDeleteFile = async (name) => {
      if (!confirm(`确定要删除文件《${name}》吗？`)) {
        return
      }
      
      showTip('正在删除文件...')
      
      try {
        const response = await fetch(`/api/book?filename=${encodeURIComponent(name)}`, {
          method: 'DELETE'
        })
        const result = await response.json()
        
        if (response.ok && result.message) {
          updateTip('文件删除成功')
          // 刷新列表
          setTimeout(() => fetchLocalBooks(), 1000)
        } else {
          updateTip(`删除失败: ${result.error || '未知错误'}`)
          setTimeout(hideTip, 2000)
        }
      } catch (error) {
        console.error('删除文件失败:', error)
        updateTip('删除文件失败')
        setTimeout(hideTip, 2000)
      }
    }

    const handleDownloadToServer = async (index, format = 'epub') => {
      // 直接在控制台打印更详细的调试信息
      console.log(`准备下载书籍，索引: ${index}, 格式: ${format}`);
      
      // 检查是否有数据
      const item = bookCache[index];
      if (!item) {
        alert('参数错误，请重新搜索');
        return;
      }
      
      // 检查是否已经在下载中
      if (isDownloading) {
        alert('已有下载任务正在进行中，请等待完成');
        return;
      }
      
      // 检查客户端ID是否存在
      if (!clientId) {
        alert('缺少客户端ID，无法开始下载');
        return;
      }
      
      // 检查SSE连接状态
      const checkSSEConnection = () => {
        console.log('检查SSE连接状态: ', globalSseConnected);
        // 强制更新一次全局状态
        globalSseConnected = sseController.isConnected();
        
        if (!globalSseConnected) {
          console.log('检测到SSE连接已断开，尝试重新连接');
          // 重试连接
          reconnectSSE();
          showTip('正在连接服务器...');
          
          // 2秒后再次检查
          setTimeout(() => {
            globalSseConnected = sseController.isConnected();
            console.log('重连后的SSE状态: ', globalSseConnected);
            
            if (!globalSseConnected) {
              // 还是无法连接
              updateTip('无法连接服务器，请刷新页面重试');
              setTimeout(hideTip, 2000);
            } else {
              // 连接成功，开始下载
              startDownload();
            }
          }, 2000);
          
          return false;
        }
        
        return true;
      };
      
      // 如果连接正常，直接开始下载
      if (checkSSEConnection()) {
        startDownload();
      }
      
      // 开始下载过程
      function startDownload() {
        // 标记下载状态
        isDownloading = true;
        
        // 生成当前下载的唯一ID
        currentDownloadId = generateUUID();
        
        console.log('开始下载，设置isDownloading=true, format=' + format + ', downloadId=' + currentDownloadId);
        console.log('[下载]当前客户端ID:', clientId);
        
        // 显示进度提示
        showTip('正在解析目录...', true);
        
        // 构建查询参数
        const params = new URLSearchParams();
        // 添加所有需要的参数
        Object.keys(item).forEach(key => {
          params.append(key, item[key]);
        });
        // 确保添加format参数
        params.append('format', format);
        // 添加下载ID参数
        params.append('downloadId', currentDownloadId);
        // 添加客户端ID参数
        params.append('clientId', clientId);
        const query = params.toString();
        
        // 请求URL
        const url = `/api/book/fetch?${query}`;
        console.log('请求URL:', url);
        console.log('请求参数:', [...params.entries()]);
        
        // 发送请求
        fetch(url)
          .then(response => {
            if (!response.ok) {
              throw new Error(`服务器响应异常: ${response.status}`);
            }
            return response.json();
          })
          .then(result => {
            console.log('下载请求响应:', result);
            if (result && result.message) {
              updateTip(result.message);
            }
          })
          .catch(error => {
            console.error('下载请求失败:', error);
            updateTip(`下载请求失败: ${error.message || '未知错误'}`);
            setTimeout(() => {
              hideTip();
              isDownloading = false;
              currentDownloadId = null;
            }, 2000);
          });
      }
    }

    const renderDownloadTable = (data) => {
      bookCache = data
      downloadTableBody.innerHTML = data.map((item, index) => `
      <tr>
        <td data-label="序号">${index + 1}</td>
        <td data-label="书名"><a href="${item.url}" target="_blank" class="book-link" title="在书源网站查看">${item.bookName}</a></td>
        <td data-label="作者">${item.author}</td>
        <td data-label="最新章节">${item.latestChapter || ''}</td>
        <td data-label="最后更新时间">${item.lastUpdateTime || ''}</td>
        <td data-label="书源">${item.sourceId}</td>
        <td data-label="操作" style="text-align: left;">
        <button class="btn btn-secondary btn-download-epub" data-index="${index}">下载EPUB</button>
        <button class="btn btn-secondary btn-download-txt" data-index="${index}">下载TXT</button>
      </td>
      </tr>
    `).join('')
    }

    const renderLocalBooksTable = (data) => {
      tableBody.innerHTML = data.map(item => `
      <tr>
        <td data-label="文件名">${item.name}</td>
        <td data-label="文件大小">${formatSize(item.size)}</td>
        <td data-label="下载时间">${formatDate(item.timestamp)}</td>
        <td data-label="操作" style="text-align: left;">
          <button class="btn btn-secondary btn-download" data-filename="${item.name}">下载</button>
          <button class="btn btn-danger btn-delete" data-filename="${item.name}">删除</button>
        </td>
      </tr>
    `).join('')
    }

    // 数据获取
    const fetchLocalBooks = async (silent = false) => {
      if (!silent) {
        showTip('正在刷新列表...')
      }
      
      try {
        const response = await fetch('/api/local/books')
        const data = await response.json()
        console.log('local-books:', data)
        if (data && data.data) {
          data.data.sort((a, b) => b.timestamp - a.timestamp)
          latestFileName = data.data.length > 0 ? data.data[0].name : ''
          renderLocalBooksTable(data.data)
        }
      } catch (error) {
        console.error('Error fetching file list:', error)
        if (!silent) {
          updateTip('刷新列表失败')
        }
      } finally {
        if (!silent) {
          hideTip()
        }
      }
    }

    const aggregatedSearch = async () => {
      const value = downloadSearchName.value.trim()
      if (!value) {
        alert("请输入书名或作者！")
        return
      }
      showTip('正在搜索...')
      searchButton.disabled = true // 搜索时禁用按钮
      downloadSearchName.disabled = true // 搜索时禁用输入框
      try {
        const response = await fetch(`/api/search/aggregated?kw=${encodeURIComponent(value)}`)
        const data = await response.json()
        console.log('search results', data)
        if (data && data.data) {
          renderDownloadTable(data.data)
        }
      } catch (error) {
        console.error('Error searching files:', error)
        updateTip('搜索失败')
      } finally {
        hideTip()
        downloadContainer.classList.add('expanded')
        searchButton.disabled = false // 搜索完成后启用按钮
        downloadSearchName.disabled = false // 搜索完成后启用输入框
      }
    }

    // SSE连接
    const initSSE = () => {
      // SSE连接状态管理
      let reconnectAttempts = 0;
      let reconnectDelay = 1000; // 初始重连延迟1秒
      const MAX_RECONNECT_ATTEMPTS = 5; // 最大重连次数
      const MAX_RECONNECT_DELAY = 30000; // 最大重连延迟30秒
      let sseConnected = false;
      let sseInstance = null;
      
      // 增加上一次收到心跳包的时间记录
      let lastHeartbeatTime = 0;
      // 检测心跳包的间隔，比心跳包发送间隔长一点
      const HEARTBEAT_INTERVAL = 15000; // 15秒
      
      // 创建并连接SSE
      const connectSSE = () => {
        // 如果已经超过最大重连次数，停止重连
        if (reconnectAttempts >= MAX_RECONNECT_ATTEMPTS) {
          console.warn(`已达到最大重连次数(${MAX_RECONNECT_ATTEMPTS})，停止重连SSE`)
          // 如果正在显示下载进度，通知用户
          if (isDownloading) {
            updateTip('服务器连接失败，下载已中断。请刷新页面重试。')
            setTimeout(hideTip, 5000)
          }
          return;
        }
        
        const {hostname, port, protocol} = window.location
        const sseProtocol = protocol.startsWith('https') ? 'https' : 'http'
        
        // 关闭之前的连接
        if (sseInstance) {
          sseInstance.close();
          sseInstance = null;
        }
        
        // 检查客户端ID是否存在
        if (!clientId) {
          console.error('[SSE]缺少客户端ID，无法建立连接');
          updateTip('客户端ID缺失，无法建立服务器连接，请刷新页面重试');
          return;
        }
        
        // 构建SSE连接URL，必须包含客户端ID
        const sseUrl = `${sseProtocol}://${hostname}:${port}/sse/book/progress?clientId=${encodeURIComponent(clientId)}`
        console.log('[SSE]正在连接到:', sseUrl)
        
        // 创建新连接
        sseInstance = new EventSource(sseUrl)
        
        // 下载完成事件
        let downloadCompleted = false
        
        // 设置下载超时检测
        let progressTimeout = null
        let lastProgressUpdate = Date.now() // 初始化为当前时间
        const MAX_PROGRESS_TIMEOUT = 15000 // 15秒无响应则认为下载失败
        
        // 添加心跳包检测定时器
        let heartbeatTimer = null;
        
        // 启动心跳包检测
        const startHeartbeatCheck = () => {
          clearInterval(heartbeatTimer);
          heartbeatTimer = setInterval(() => {
            const now = Date.now();
            // 如果最后一次心跳包时间不为0，则检查时间间隔
            if (lastHeartbeatTime > 0 && now - lastHeartbeatTime > HEARTBEAT_INTERVAL) {
              const lastTime = new Date(lastHeartbeatTime).toLocaleTimeString();
              const currentTime = new Date().toLocaleTimeString();
              const interval = (now - lastHeartbeatTime)/1000;
              console.warn(`[SSE]心跳包超时：最后心跳包时间 ${lastTime}，当前时间 ${currentTime}，间隔: ${interval}秒`)
              // 心跳包超时，认为连接已断开
              if (sseInstance) {
                console.warn('心跳包超时，关闭当前连接并重试')
                sseInstance.close();
                sseInstance = null;
                sseConnected = false;
                globalSseConnected = false; // 更新全局状态
                
                // 如果正在下载，显示重连信息
                if (isDownloading) {
                  updateTip(`服务器连接已断开，正在尝试重连(${reconnectAttempts+1}/${MAX_RECONNECT_ATTEMPTS})...`)
                  
                  // 如果超过最大重连次数，重置下载状态
                  if (reconnectAttempts + 1 >= MAX_RECONNECT_ATTEMPTS) {
                    isDownloading = false
                    downloadCompleted = false
                    console.log('达到最大重连次数，重置下载状态')
                    
                    // 更新提示
                    updateTip('服务器连接失败，请刷新页面重试')
                    setTimeout(() => {
                      hideTip()
                    }, 3000)
                  }
                }
                
                // 使用指数退避算法重连
                reconnectAttempts++;
                reconnectDelay = Math.min(reconnectDelay * 2, MAX_RECONNECT_DELAY);
                
                setTimeout(() => {
                  connectSSE();
                }, reconnectDelay);
              }
            }
          }, 5000); // 每5秒检测一次
        }
        
        // 初始化时立即启动心跳包检测
        startHeartbeatCheck();
        
        const checkProgressTimeout = () => {
          // 清除之前的超时定时器
          if (progressTimeout) {
            clearTimeout(progressTimeout)
          }
          
          // 如果正在下载，设置超时检测
          if (isDownloading && !downloadCompleted) {
            progressTimeout = setTimeout(() => {
              // 检查是否超过最大超时时间
              const now = Date.now()
              console.log(`[SSE]检查进度超时，上次更新: ${new Date(lastProgressUpdate).toLocaleTimeString()}, 当前时间: ${new Date(now).toLocaleTimeString()}, 间隔: ${(now - lastProgressUpdate)/1000}秒`);
          
              if (now - lastProgressUpdate > MAX_PROGRESS_TIMEOUT) {
                console.error('下载超时，可能已断开连接')
                updateTip('下载超时，请刷新页面重试')
                // 重置进度定时器
                if (progressTimeout) {
                  clearTimeout(progressTimeout)
                  progressTimeout = null
                }
                // 重置下载状态
                isDownloading = false
                downloadCompleted = false
                console.log('超时时重置下载状态')
                // 3秒后关闭提示
                setTimeout(() => {
                  hideTip()
                }, 3000)
              } else {
                // 继续检测
                checkProgressTimeout()
              }
            }, 5000) // 每5秒检测一次
          }
        }
        
        // 连接建立成功
        sseInstance.onopen = () => {
          console.log('[SSE]连接已建立，准备接收消息')
          console.log('[SSE]当前客户端ID:', clientId)
          sseConnected = true;
          globalSseConnected = true; // 更新全局状态
          reconnectAttempts = 0; // 重置重连尝试次数
          reconnectDelay = 1000; // 重置重连延迟
          lastProgressUpdate = Date.now(); // 更新最后活动时间
          lastHeartbeatTime = Date.now(); // 更新最后心跳包时间
          console.log('[SSE]连接状态更新为: connected =', sseConnected);
          
          // 如果正在显示连接中消息，更新为连接成功
          const tipContent = tipText.innerHTML;
          if (tipContent.includes('正在连接') || tipContent.includes('重新连接')) {
            updateTip('服务器连接成功');
            setTimeout(hideTip, 1000);
          }
        }
        
        sseInstance.onmessage = (e) => {
          // 处理旧版心跳包格式
          if (e.data === ':heartbeat') {
            // 兼容旧版心跳包格式
            lastHeartbeatTime = Date.now();
            lastProgressUpdate = Date.now();
            console.log('[SSE]收到旧式心跳包');
            return;
          }
          
          // 特殊处理纯文本消息
          if (e.data === 'connected') {
            console.log('[SSE]连接成功，收到初始连接消息');
            lastHeartbeatTime = Date.now(); // 将初始连接消息也视为心跳包
            return;
          }
          
          // 处理包含clientId的连接消息
          if (e.data.includes('"type":"connected"') && e.data.includes('"clientId"')) {
            try {
              const data = JSON.parse(e.data);
              if (data.clientId) {
                console.log('[SSE]连接成功，客户端ID:', data.clientId);
                clientId = data.clientId; // 更新客户端ID（如果服务器返回了新的）
              }
              lastHeartbeatTime = Date.now(); // 将初始连接消息也视为心跳包
              return;
            } catch (parseError) {
              console.error('[SSE]解析连接消息失败:', parseError);
            }
          }
          
          try {
            const data = JSON.parse(e.data)
            
            // 处理心跳包消息
            if (data.type === 'heartbeat') {
              lastHeartbeatTime = Date.now();
              // 收到心跳包，更新最后活动时间
              lastProgressUpdate = Date.now();
              return;
            }
            
            // 处理错误消息
            if (data.type === 'book-download-error') {
              // 显示错误信息
              updateTip(`下载出错: ${data.message}`)
              console.error('下载出错:', data.message)
              // 停止下载状态
              isDownloading = false
              currentDownloadId = null // 重置下载ID
              console.log('错误时重置下载状态')
              // 清除超时定时器
              if (progressTimeout) {
                clearTimeout(progressTimeout)
                progressTimeout = null
              }
              // 3秒后隐藏提示
              setTimeout(() => {
                hideTip()
                downloadCompleted = false
              }, 3000)
              return
            }
            
            // 处理普通进度消息
            if (data.type === 'book-download') {
              // 更新最后活动时间
              lastProgressUpdate = Date.now()
              
              // 启动超时检测
              checkProgressTimeout()
              
              // 确保正在下载中
              if (!isDownloading) {
                isDownloading = true
                showTip('正在下载章节...', true)
              }
              
              // 更新下载进度
              if (data.index > 0 && data.total > 0) {
                // 更新进度条和文本
                updateProgress(data.index, data.total)
                
                // 更新提示文本，包含进度百分比
                const percent = Math.floor((data.index / data.total) * 100)
                updateTip(`正在下载章节 ${percent}%(${data.index}/${data.total})`)
                
                // 检查是否下载完成
                if (data.index >= data.total && !downloadCompleted) {
                  updateTip('所有章节下载完成，准备处理文件...')
                }
              }
            }
            
            // 处理下载完成消息
            if (data.type === 'book-download-complete' && !downloadCompleted) {
              console.log('[SSE]收到下载完成消息：', data);
              downloadCompleted = true;
              // 清除超时定时器
              if (progressTimeout) {
                clearTimeout(progressTimeout);
                progressTimeout = null;
              }
              updateTip('下载完成，准备处理文件...');
              
              // 确保进度条显示100%
              if (data.total > 0) {
                updateProgress(data.total, data.total);
              }
              
              // 在下载完成后立即更新最后心跳包时间，避免心跳检测超时
              lastHeartbeatTime = Date.now();
              lastProgressUpdate = Date.now();
              
              // 设置一个延迟定时器来重置下载状态
              // 等待服务器处理文件
              setTimeout(() => {
                // 静默刷新书籍列表
                fetchLocalBooks(true).then(() => {
                  if (latestFileName) {
                    updateTip('下载完成，即将开始下载文件...')
                    
                    // 延迟一秒后开始下载，确保UI更新完成
                    setTimeout(() => {
                      hideTip()
                      isDownloading = false // 在隐藏提示前就重置下载状态
                      currentDownloadId = null // 重置下载ID
                      console.log('重置下载状态，可以进行新的下载')
                      // 使用fetch API获取下载URL，然后通过动态iframe触发下载
                      fetch(`/api/book/download-url?filename=${encodeURIComponent(latestFileName)}`)
                        .then(response => response.json())
                        .then(data => {
                          if (data.downloadURL) {
                            // 创建隐藏的iframe来触发下载
                            const iframe = document.createElement('iframe');
                            iframe.style.display = 'none';
                            iframe.src = data.downloadURL;
                            document.body.appendChild(iframe);
                            
                            // 在下载开始后移除iframe
                            setTimeout(() => {
                              document.body.removeChild(iframe);
                            }, 1000);
                          }
                        })
                        .catch(error => {
                          console.error('获取下载URL失败:', error);
                        });
                      
                      // 重置下载完成标志
                      downloadCompleted = false
                    }, 1000)
                  } else {
                    updateTip('下载完成！')
                    // 在隐藏提示前就重置下载状态
                    isDownloading = false
                    currentDownloadId = null // 重置下载ID
                    console.log('重置下载状态，可以进行新的下载')
                    setTimeout(() => {
                      hideTip()
                      // 重置下载完成标志
                      downloadCompleted = false
                    }, 2000)
                  }
                })
              }, 1000)
            }
          } catch (error) {
            console.error('解析SSE消息错误:', error, '原始消息:', e.data)
            // 尝试处理非JSON格式的消息，避免影响用户体验
            if (e.data && typeof e.data === 'string') {
              if (e.data.includes('error') || e.data.includes('错误')) {
                // 简单显示错误消息
                updateTip('服务器发送了错误消息: ' + + e.data)
              }
            }
          }
        }
        
        // 连接错误处理
        sseInstance.onerror = (error) => {
          console.error('[SSE]连接错误:', error)
          sseConnected = false;
          globalSseConnected = false; // 更新全局状态
          console.log('[SSE]连接状态更新为: connected =', sseConnected);
          
          // 如果正在下载，显示连接中断提示
          if (isDownloading) {
            updateTip(`服务器连接中断，正在尝试重连(${reconnectAttempts+1}/${MAX_RECONNECT_ATTEMPTS})...`)
            
            // 如果超过最大重连次数，重置下载状态
            if (reconnectAttempts + 1 >= MAX_RECONNECT_ATTEMPTS) {
              isDownloading = false
              downloadCompleted = false
              console.log('SSE错误：达到最大重连次数，重置下载状态')
              
              // 更新提示
              updateTip('服务器连接失败，请刷新页面重试')
              setTimeout(() => {
                hideTip()
              }, 3000)
            }
          }
          
          // 关闭当前连接
          sseInstance.close()
          sseInstance = null
          
          // 清除心跳包检测定时器
          if (heartbeatTimer) {
            clearInterval(heartbeatTimer);
            heartbeatTimer = null;
          }
          
          // 使用指数退避算法重连
          reconnectAttempts++;
          // 计算下次重连延迟（指数增长但不超过最大值）
          reconnectDelay = Math.min(reconnectDelay * 2, MAX_RECONNECT_DELAY);
          
          console.log(`将在 ${reconnectDelay/1000} 秒后尝试第 ${reconnectAttempts} 次重连`)
          
          // 延迟重连
          setTimeout(() => {
            connectSSE();
          }, reconnectDelay);
        }
      }
      
      // 初始连接
      connectSSE();
      
      // 添加页面可见性变化监听，页面变为可见时检查连接状态
      document.addEventListener('visibilitychange', () => {
        if (document.visibilityState === 'visible' && !sseConnected && reconnectAttempts < MAX_RECONNECT_ATTEMPTS) {
          console.log('页面重新可见，检查SSE连接状态');
          // 重置重连参数，重新尝试连接
          reconnectAttempts = 0;
          reconnectDelay = 1000;
          connectSSE();
        }
      });
      
      // 添加窗口事件，在窗口关闭前清理资源
      window.addEventListener('beforeunload', () => {
        if (sseInstance) {
          sseInstance.close();
          sseInstance = null;
        }
      });
      
      // 返回连接控制函数，供外部调用
      return {
        connect: () => {
          // 在重新连接前先关闭现有连接
          if (sseInstance) {
            sseInstance.close();
            sseInstance = null;
          }
          // 重置重连尝试次数
          reconnectAttempts = 0;
          reconnectDelay = 1000;
          // 尝试重新连接
          connectSSE();
        },
        isConnected: () => {
          try {
            // 确保这个方法在被调用时始终返回布尔值
            const connected = (sseConnected === true);
            // 更新全局变量
            globalSseConnected = connected;
            return connected;
          } catch (e) {
            console.error('检查SSE连接状态时出错:', e);
            return false;
          }
        },
        getReconnectAttempts: () => reconnectAttempts,
        resetReconnectAttempts: () => {
          reconnectAttempts = 0;
          reconnectDelay = 1000;
        }
      };
    }

    // 初始化SSE连接
    const sseController = initSSE();
    
    // 全局变量，表示是否已经执行了初始化检查
    let initialCheckDone = false;
    
    // 每10秒检查一次SSE连接状态，确保全局状态与实际状态一致
    setInterval(() => {
      globalSseConnected = sseController.isConnected();
      console.log('定期检查SSE连接状态：', globalSseConnected);
    }, 10000);
    
    // 添加用户主动重连功能
    const reconnectSSE = () => {
      console.log('执行重新连接SSE操作');
      // 尝试重新连接
      sseController.connect();
      
      // 重置SSE连接检测标志
      initialCheckDone = false;
      
      // 一秒后检查连接状态
      setTimeout(() => {
        globalSseConnected = sseController.isConnected();
        console.log('重连后的连接状态：', globalSseConnected);
        initialCheckDone = true;
      }, 1000);
      
      // 显示重连提示（只有在没有下载任务时才显示）
      if (!isDownloading) {
        showTip('正在重新连接服务器...');
        setTimeout(hideTip, 1000);
      }
    }

    // 事件绑定
    searchButton.addEventListener('click', aggregatedSearch)
    
    downloadSearchName.addEventListener('keypress', (e) => {
      if (e.key === 'Enter') {
        aggregatedSearch()
      }
    })
    
    refreshListButton.addEventListener('click', () => {
      // 用户点击刷新按钮时，尝试重新连接SSE
      if (sseController.getReconnectAttempts() >= 5) {
        reconnectSSE();
      }
      fetchLocalBooks()
    });
    
    // 添加停止下载按钮事件监听器
    stopDownloadBtn.addEventListener('click', handleStopDownload);
    
    // 委托事件监听，用于下载按钮
    document.addEventListener('click', (e) => {
      const target = e.target
      
      // 检查是否点击的是下载EPUB按钮
      if (target.classList.contains('btn-download-epub')) {
        const index = parseInt(target.getAttribute('data-index'));
        if (!isNaN(index)) {
          console.log(`点击了EPUB下载按钮，索引: ${index}`);
          handleDownloadToServer(index, 'epub');
        }
        return;
      }
      
      // 检查是否点击的是下载TXT按钮
      if (target.classList.contains('btn-download-txt')) {
        const index = parseInt(target.getAttribute('data-index'));
        if (!isNaN(index)) {
          console.log(`点击了TXT下载按钮，索引: ${index}`);
          handleDownloadToServer(index, 'txt');
        }
        return;
      }
      
      // 检查是否点击的是当前已下载文件的下载按钮
      if (target.classList.contains('btn-download')) {
        const filename = target.getAttribute('data-filename')
        if (filename) {
          // 下载本地文件
          handleDownloadFileToLocal(filename)
        }
        return
      }
      
      // 检查是否点击的是删除按钮
      if (target.classList.contains('btn-delete')) {
        const filename = target.getAttribute('data-filename')
        if (filename) {
          handleDeleteFile(filename)
        }
      }
    })

    // 初始化
    fetchLocalBooks()
    
    // 初始化后立即检查一次SSE连接状态
    setTimeout(() => {
      globalSseConnected = sseController.isConnected();
      console.log('初始化检查SSE连接状态：', globalSseConnected);
      console.log('当前客户端ID：', clientId);
      initialCheckDone = true;
      
      // 如果连接失败，尝试重连
      if (!globalSseConnected) {
        console.log('初始化检测到连接未建立，尝试重连');
        reconnectSSE();
      }
    }, 1000);
  })
</script>
  <footer class="footer">
    <div class="wrap-container">
      <div class="footer-content" style="background-color: #f8f8f8; width: 100%; border-radius: 4px; border-top: 1px solid #e0e0e0;">
        <div class="footer-links">
          <span class="copyright">© 2025 Go Novel</span>
          <span class="divider">|</span>
          <a href="https://github.com/zsyo/go-novel" target="_blank" class="github-link" title="查看GitHub仓库">GitHub</a>
        </div>
      </div>
    </div>
  </footer>
</body>
</html>